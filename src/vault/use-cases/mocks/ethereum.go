// Code generated by MockGen. DO NOT EDIT.
// Source: ethereum.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	entities "github.com/ConsenSys/orchestrate-hashicorp-vault-plugin/src/vault/entities"
	usecases "github.com/ConsenSys/orchestrate-hashicorp-vault-plugin/src/vault/use-cases"
	types "github.com/consensys/quorum/core/types"
	gomock "github.com/golang/mock/gomock"
	logical "github.com/hashicorp/vault/sdk/logical"
	reflect "reflect"
)

// MockETHUseCases is a mock of ETHUseCases interface
type MockETHUseCases struct {
	ctrl     *gomock.Controller
	recorder *MockETHUseCasesMockRecorder
}

// MockETHUseCasesMockRecorder is the mock recorder for MockETHUseCases
type MockETHUseCasesMockRecorder struct {
	mock *MockETHUseCases
}

// NewMockETHUseCases creates a new mock instance
func NewMockETHUseCases(ctrl *gomock.Controller) *MockETHUseCases {
	mock := &MockETHUseCases{ctrl: ctrl}
	mock.recorder = &MockETHUseCasesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockETHUseCases) EXPECT() *MockETHUseCasesMockRecorder {
	return m.recorder
}

// CreateAccount mocks base method
func (m *MockETHUseCases) CreateAccount() usecases.CreateAccountUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAccount")
	ret0, _ := ret[0].(usecases.CreateAccountUseCase)
	return ret0
}

// CreateAccount indicates an expected call of CreateAccount
func (mr *MockETHUseCasesMockRecorder) CreateAccount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccount", reflect.TypeOf((*MockETHUseCases)(nil).CreateAccount))
}

// GetAccount mocks base method
func (m *MockETHUseCases) GetAccount() usecases.GetAccountUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccount")
	ret0, _ := ret[0].(usecases.GetAccountUseCase)
	return ret0
}

// GetAccount indicates an expected call of GetAccount
func (mr *MockETHUseCasesMockRecorder) GetAccount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockETHUseCases)(nil).GetAccount))
}

// ListAccounts mocks base method
func (m *MockETHUseCases) ListAccounts() usecases.ListAccountsUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListAccounts")
	ret0, _ := ret[0].(usecases.ListAccountsUseCase)
	return ret0
}

// ListAccounts indicates an expected call of ListAccounts
func (mr *MockETHUseCasesMockRecorder) ListAccounts() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccounts", reflect.TypeOf((*MockETHUseCases)(nil).ListAccounts))
}

// ListNamespaces mocks base method
func (m *MockETHUseCases) ListNamespaces() usecases.ListNamespacesUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListNamespaces")
	ret0, _ := ret[0].(usecases.ListNamespacesUseCase)
	return ret0
}

// ListNamespaces indicates an expected call of ListNamespaces
func (mr *MockETHUseCasesMockRecorder) ListNamespaces() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNamespaces", reflect.TypeOf((*MockETHUseCases)(nil).ListNamespaces))
}

// SignPayload mocks base method
func (m *MockETHUseCases) SignPayload() usecases.SignUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignPayload")
	ret0, _ := ret[0].(usecases.SignUseCase)
	return ret0
}

// SignPayload indicates an expected call of SignPayload
func (mr *MockETHUseCasesMockRecorder) SignPayload() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignPayload", reflect.TypeOf((*MockETHUseCases)(nil).SignPayload))
}

// SignTransaction mocks base method
func (m *MockETHUseCases) SignTransaction() usecases.SignTransactionUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignTransaction")
	ret0, _ := ret[0].(usecases.SignTransactionUseCase)
	return ret0
}

// SignTransaction indicates an expected call of SignTransaction
func (mr *MockETHUseCasesMockRecorder) SignTransaction() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignTransaction", reflect.TypeOf((*MockETHUseCases)(nil).SignTransaction))
}

// SignQuorumPrivateTransaction mocks base method
func (m *MockETHUseCases) SignQuorumPrivateTransaction() usecases.SignQuorumPrivateTransactionUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignQuorumPrivateTransaction")
	ret0, _ := ret[0].(usecases.SignQuorumPrivateTransactionUseCase)
	return ret0
}

// SignQuorumPrivateTransaction indicates an expected call of SignQuorumPrivateTransaction
func (mr *MockETHUseCasesMockRecorder) SignQuorumPrivateTransaction() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignQuorumPrivateTransaction", reflect.TypeOf((*MockETHUseCases)(nil).SignQuorumPrivateTransaction))
}

// SignEEATransaction mocks base method
func (m *MockETHUseCases) SignEEATransaction() usecases.SignEEATransactionUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignEEATransaction")
	ret0, _ := ret[0].(usecases.SignEEATransactionUseCase)
	return ret0
}

// SignEEATransaction indicates an expected call of SignEEATransaction
func (mr *MockETHUseCasesMockRecorder) SignEEATransaction() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignEEATransaction", reflect.TypeOf((*MockETHUseCases)(nil).SignEEATransaction))
}

// MockCreateAccountUseCase is a mock of CreateAccountUseCase interface
type MockCreateAccountUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockCreateAccountUseCaseMockRecorder
}

// MockCreateAccountUseCaseMockRecorder is the mock recorder for MockCreateAccountUseCase
type MockCreateAccountUseCaseMockRecorder struct {
	mock *MockCreateAccountUseCase
}

// NewMockCreateAccountUseCase creates a new mock instance
func NewMockCreateAccountUseCase(ctrl *gomock.Controller) *MockCreateAccountUseCase {
	mock := &MockCreateAccountUseCase{ctrl: ctrl}
	mock.recorder = &MockCreateAccountUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCreateAccountUseCase) EXPECT() *MockCreateAccountUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockCreateAccountUseCase) Execute(ctx context.Context, namespace, importedPrivKey string) (*entities.ETHAccount, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, namespace, importedPrivKey)
	ret0, _ := ret[0].(*entities.ETHAccount)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockCreateAccountUseCaseMockRecorder) Execute(ctx, namespace, importedPrivKey interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockCreateAccountUseCase)(nil).Execute), ctx, namespace, importedPrivKey)
}

// WithStorage mocks base method
func (m *MockCreateAccountUseCase) WithStorage(storage logical.Storage) usecases.CreateAccountUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithStorage", storage)
	ret0, _ := ret[0].(usecases.CreateAccountUseCase)
	return ret0
}

// WithStorage indicates an expected call of WithStorage
func (mr *MockCreateAccountUseCaseMockRecorder) WithStorage(storage interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithStorage", reflect.TypeOf((*MockCreateAccountUseCase)(nil).WithStorage), storage)
}

// MockGetAccountUseCase is a mock of GetAccountUseCase interface
type MockGetAccountUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockGetAccountUseCaseMockRecorder
}

// MockGetAccountUseCaseMockRecorder is the mock recorder for MockGetAccountUseCase
type MockGetAccountUseCaseMockRecorder struct {
	mock *MockGetAccountUseCase
}

// NewMockGetAccountUseCase creates a new mock instance
func NewMockGetAccountUseCase(ctrl *gomock.Controller) *MockGetAccountUseCase {
	mock := &MockGetAccountUseCase{ctrl: ctrl}
	mock.recorder = &MockGetAccountUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockGetAccountUseCase) EXPECT() *MockGetAccountUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockGetAccountUseCase) Execute(ctx context.Context, address, namespace string) (*entities.ETHAccount, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, address, namespace)
	ret0, _ := ret[0].(*entities.ETHAccount)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockGetAccountUseCaseMockRecorder) Execute(ctx, address, namespace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockGetAccountUseCase)(nil).Execute), ctx, address, namespace)
}

// WithStorage mocks base method
func (m *MockGetAccountUseCase) WithStorage(storage logical.Storage) usecases.GetAccountUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithStorage", storage)
	ret0, _ := ret[0].(usecases.GetAccountUseCase)
	return ret0
}

// WithStorage indicates an expected call of WithStorage
func (mr *MockGetAccountUseCaseMockRecorder) WithStorage(storage interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithStorage", reflect.TypeOf((*MockGetAccountUseCase)(nil).WithStorage), storage)
}

// MockListAccountsUseCase is a mock of ListAccountsUseCase interface
type MockListAccountsUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockListAccountsUseCaseMockRecorder
}

// MockListAccountsUseCaseMockRecorder is the mock recorder for MockListAccountsUseCase
type MockListAccountsUseCaseMockRecorder struct {
	mock *MockListAccountsUseCase
}

// NewMockListAccountsUseCase creates a new mock instance
func NewMockListAccountsUseCase(ctrl *gomock.Controller) *MockListAccountsUseCase {
	mock := &MockListAccountsUseCase{ctrl: ctrl}
	mock.recorder = &MockListAccountsUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockListAccountsUseCase) EXPECT() *MockListAccountsUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockListAccountsUseCase) Execute(ctx context.Context, namespace string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, namespace)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockListAccountsUseCaseMockRecorder) Execute(ctx, namespace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockListAccountsUseCase)(nil).Execute), ctx, namespace)
}

// WithStorage mocks base method
func (m *MockListAccountsUseCase) WithStorage(storage logical.Storage) usecases.ListAccountsUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithStorage", storage)
	ret0, _ := ret[0].(usecases.ListAccountsUseCase)
	return ret0
}

// WithStorage indicates an expected call of WithStorage
func (mr *MockListAccountsUseCaseMockRecorder) WithStorage(storage interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithStorage", reflect.TypeOf((*MockListAccountsUseCase)(nil).WithStorage), storage)
}

// MockSignUseCase is a mock of SignUseCase interface
type MockSignUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockSignUseCaseMockRecorder
}

// MockSignUseCaseMockRecorder is the mock recorder for MockSignUseCase
type MockSignUseCaseMockRecorder struct {
	mock *MockSignUseCase
}

// NewMockSignUseCase creates a new mock instance
func NewMockSignUseCase(ctrl *gomock.Controller) *MockSignUseCase {
	mock := &MockSignUseCase{ctrl: ctrl}
	mock.recorder = &MockSignUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSignUseCase) EXPECT() *MockSignUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSignUseCase) Execute(ctx context.Context, address, namespace, data string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, address, namespace, data)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockSignUseCaseMockRecorder) Execute(ctx, address, namespace, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSignUseCase)(nil).Execute), ctx, address, namespace, data)
}

// WithStorage mocks base method
func (m *MockSignUseCase) WithStorage(storage logical.Storage) usecases.SignUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithStorage", storage)
	ret0, _ := ret[0].(usecases.SignUseCase)
	return ret0
}

// WithStorage indicates an expected call of WithStorage
func (mr *MockSignUseCaseMockRecorder) WithStorage(storage interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithStorage", reflect.TypeOf((*MockSignUseCase)(nil).WithStorage), storage)
}

// MockSignTransactionUseCase is a mock of SignTransactionUseCase interface
type MockSignTransactionUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockSignTransactionUseCaseMockRecorder
}

// MockSignTransactionUseCaseMockRecorder is the mock recorder for MockSignTransactionUseCase
type MockSignTransactionUseCaseMockRecorder struct {
	mock *MockSignTransactionUseCase
}

// NewMockSignTransactionUseCase creates a new mock instance
func NewMockSignTransactionUseCase(ctrl *gomock.Controller) *MockSignTransactionUseCase {
	mock := &MockSignTransactionUseCase{ctrl: ctrl}
	mock.recorder = &MockSignTransactionUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSignTransactionUseCase) EXPECT() *MockSignTransactionUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSignTransactionUseCase) Execute(ctx context.Context, address, namespace, chainID string, tx *types.Transaction) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, address, namespace, chainID, tx)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockSignTransactionUseCaseMockRecorder) Execute(ctx, address, namespace, chainID, tx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSignTransactionUseCase)(nil).Execute), ctx, address, namespace, chainID, tx)
}

// WithStorage mocks base method
func (m *MockSignTransactionUseCase) WithStorage(storage logical.Storage) usecases.SignTransactionUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithStorage", storage)
	ret0, _ := ret[0].(usecases.SignTransactionUseCase)
	return ret0
}

// WithStorage indicates an expected call of WithStorage
func (mr *MockSignTransactionUseCaseMockRecorder) WithStorage(storage interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithStorage", reflect.TypeOf((*MockSignTransactionUseCase)(nil).WithStorage), storage)
}

// MockSignQuorumPrivateTransactionUseCase is a mock of SignQuorumPrivateTransactionUseCase interface
type MockSignQuorumPrivateTransactionUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockSignQuorumPrivateTransactionUseCaseMockRecorder
}

// MockSignQuorumPrivateTransactionUseCaseMockRecorder is the mock recorder for MockSignQuorumPrivateTransactionUseCase
type MockSignQuorumPrivateTransactionUseCaseMockRecorder struct {
	mock *MockSignQuorumPrivateTransactionUseCase
}

// NewMockSignQuorumPrivateTransactionUseCase creates a new mock instance
func NewMockSignQuorumPrivateTransactionUseCase(ctrl *gomock.Controller) *MockSignQuorumPrivateTransactionUseCase {
	mock := &MockSignQuorumPrivateTransactionUseCase{ctrl: ctrl}
	mock.recorder = &MockSignQuorumPrivateTransactionUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSignQuorumPrivateTransactionUseCase) EXPECT() *MockSignQuorumPrivateTransactionUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSignQuorumPrivateTransactionUseCase) Execute(ctx context.Context, address, namespace string, tx *types.Transaction) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, address, namespace, tx)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockSignQuorumPrivateTransactionUseCaseMockRecorder) Execute(ctx, address, namespace, tx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSignQuorumPrivateTransactionUseCase)(nil).Execute), ctx, address, namespace, tx)
}

// WithStorage mocks base method
func (m *MockSignQuorumPrivateTransactionUseCase) WithStorage(storage logical.Storage) usecases.SignQuorumPrivateTransactionUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithStorage", storage)
	ret0, _ := ret[0].(usecases.SignQuorumPrivateTransactionUseCase)
	return ret0
}

// WithStorage indicates an expected call of WithStorage
func (mr *MockSignQuorumPrivateTransactionUseCaseMockRecorder) WithStorage(storage interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithStorage", reflect.TypeOf((*MockSignQuorumPrivateTransactionUseCase)(nil).WithStorage), storage)
}

// MockSignEEATransactionUseCase is a mock of SignEEATransactionUseCase interface
type MockSignEEATransactionUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockSignEEATransactionUseCaseMockRecorder
}

// MockSignEEATransactionUseCaseMockRecorder is the mock recorder for MockSignEEATransactionUseCase
type MockSignEEATransactionUseCaseMockRecorder struct {
	mock *MockSignEEATransactionUseCase
}

// NewMockSignEEATransactionUseCase creates a new mock instance
func NewMockSignEEATransactionUseCase(ctrl *gomock.Controller) *MockSignEEATransactionUseCase {
	mock := &MockSignEEATransactionUseCase{ctrl: ctrl}
	mock.recorder = &MockSignEEATransactionUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSignEEATransactionUseCase) EXPECT() *MockSignEEATransactionUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockSignEEATransactionUseCase) Execute(ctx context.Context, address, namespace, chainID string, tx *types.Transaction, privateArgs *entities.PrivateETHTransactionParams) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, address, namespace, chainID, tx, privateArgs)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockSignEEATransactionUseCaseMockRecorder) Execute(ctx, address, namespace, chainID, tx, privateArgs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockSignEEATransactionUseCase)(nil).Execute), ctx, address, namespace, chainID, tx, privateArgs)
}

// WithStorage mocks base method
func (m *MockSignEEATransactionUseCase) WithStorage(storage logical.Storage) usecases.SignEEATransactionUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithStorage", storage)
	ret0, _ := ret[0].(usecases.SignEEATransactionUseCase)
	return ret0
}

// WithStorage indicates an expected call of WithStorage
func (mr *MockSignEEATransactionUseCaseMockRecorder) WithStorage(storage interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithStorage", reflect.TypeOf((*MockSignEEATransactionUseCase)(nil).WithStorage), storage)
}

// MockListNamespacesUseCase is a mock of ListNamespacesUseCase interface
type MockListNamespacesUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockListNamespacesUseCaseMockRecorder
}

// MockListNamespacesUseCaseMockRecorder is the mock recorder for MockListNamespacesUseCase
type MockListNamespacesUseCaseMockRecorder struct {
	mock *MockListNamespacesUseCase
}

// NewMockListNamespacesUseCase creates a new mock instance
func NewMockListNamespacesUseCase(ctrl *gomock.Controller) *MockListNamespacesUseCase {
	mock := &MockListNamespacesUseCase{ctrl: ctrl}
	mock.recorder = &MockListNamespacesUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockListNamespacesUseCase) EXPECT() *MockListNamespacesUseCaseMockRecorder {
	return m.recorder
}

// Execute mocks base method
func (m *MockListNamespacesUseCase) Execute(ctx context.Context) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute
func (mr *MockListNamespacesUseCaseMockRecorder) Execute(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockListNamespacesUseCase)(nil).Execute), ctx)
}

// WithStorage mocks base method
func (m *MockListNamespacesUseCase) WithStorage(storage logical.Storage) usecases.ListNamespacesUseCase {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithStorage", storage)
	ret0, _ := ret[0].(usecases.ListNamespacesUseCase)
	return ret0
}

// WithStorage indicates an expected call of WithStorage
func (mr *MockListNamespacesUseCaseMockRecorder) WithStorage(storage interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithStorage", reflect.TypeOf((*MockListNamespacesUseCase)(nil).WithStorage), storage)
}
